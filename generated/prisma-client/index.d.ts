// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  application: (where?: ApplicationWhereInput) => Promise<boolean>;
  club: (where?: ClubWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  notification: (where?: NotificationWhereInput) => Promise<boolean>;
  question: (where?: QuestionWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  application: (
    where: ApplicationWhereUniqueInput
  ) => ApplicationNullablePromise;
  applications: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Application>;
  applicationsConnection: (args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ApplicationConnectionPromise;
  club: (where: ClubWhereUniqueInput) => ClubNullablePromise;
  clubs: (args?: {
    where?: ClubWhereInput;
    orderBy?: ClubOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Club>;
  clubsConnection: (args?: {
    where?: ClubWhereInput;
    orderBy?: ClubOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClubConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  notification: (
    where: NotificationWhereUniqueInput
  ) => NotificationNullablePromise;
  notifications: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Notification>;
  notificationsConnection: (args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NotificationConnectionPromise;
  question: (where: QuestionWhereUniqueInput) => QuestionNullablePromise;
  questions: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Question>;
  questionsConnection: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomNullablePromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createApplication: (data: ApplicationCreateInput) => ApplicationPromise;
  updateApplication: (args: {
    data: ApplicationUpdateInput;
    where: ApplicationWhereUniqueInput;
  }) => ApplicationPromise;
  updateManyApplications: (args: {
    data: ApplicationUpdateManyMutationInput;
    where?: ApplicationWhereInput;
  }) => BatchPayloadPromise;
  upsertApplication: (args: {
    where: ApplicationWhereUniqueInput;
    create: ApplicationCreateInput;
    update: ApplicationUpdateInput;
  }) => ApplicationPromise;
  deleteApplication: (where: ApplicationWhereUniqueInput) => ApplicationPromise;
  deleteManyApplications: (
    where?: ApplicationWhereInput
  ) => BatchPayloadPromise;
  createClub: (data: ClubCreateInput) => ClubPromise;
  updateClub: (args: {
    data: ClubUpdateInput;
    where: ClubWhereUniqueInput;
  }) => ClubPromise;
  updateManyClubs: (args: {
    data: ClubUpdateManyMutationInput;
    where?: ClubWhereInput;
  }) => BatchPayloadPromise;
  upsertClub: (args: {
    where: ClubWhereUniqueInput;
    create: ClubCreateInput;
    update: ClubUpdateInput;
  }) => ClubPromise;
  deleteClub: (where: ClubWhereUniqueInput) => ClubPromise;
  deleteManyClubs: (where?: ClubWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createNotification: (data: NotificationCreateInput) => NotificationPromise;
  updateNotification: (args: {
    data: NotificationUpdateInput;
    where: NotificationWhereUniqueInput;
  }) => NotificationPromise;
  updateManyNotifications: (args: {
    data: NotificationUpdateManyMutationInput;
    where?: NotificationWhereInput;
  }) => BatchPayloadPromise;
  upsertNotification: (args: {
    where: NotificationWhereUniqueInput;
    create: NotificationCreateInput;
    update: NotificationUpdateInput;
  }) => NotificationPromise;
  deleteNotification: (
    where: NotificationWhereUniqueInput
  ) => NotificationPromise;
  deleteManyNotifications: (
    where?: NotificationWhereInput
  ) => BatchPayloadPromise;
  createQuestion: (data: QuestionCreateInput) => QuestionPromise;
  updateQuestion: (args: {
    data: QuestionUpdateInput;
    where: QuestionWhereUniqueInput;
  }) => QuestionPromise;
  updateManyQuestions: (args: {
    data: QuestionUpdateManyMutationInput;
    where?: QuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestion: (args: {
    where: QuestionWhereUniqueInput;
    create: QuestionCreateInput;
    update: QuestionUpdateInput;
  }) => QuestionPromise;
  deleteQuestion: (where: QuestionWhereUniqueInput) => QuestionPromise;
  deleteManyQuestions: (where?: QuestionWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  application: (
    where?: ApplicationSubscriptionWhereInput
  ) => ApplicationSubscriptionPayloadSubscription;
  club: (
    where?: ClubSubscriptionWhereInput
  ) => ClubSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  notification: (
    where?: NotificationSubscriptionWhereInput
  ) => NotificationSubscriptionPayloadSubscription;
  question: (
    where?: QuestionSubscriptionWhereInput
  ) => QuestionSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "encryptedPassword_ASC"
  | "encryptedPassword_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "studentNumber_ASC"
  | "studentNumber_DESC"
  | "Name_ASC"
  | "Name_DESC"
  | "isMaster_ASC"
  | "isMaster_DESC"
  | "sex_ASC"
  | "sex_DESC"
  | "loginSecret_ASC"
  | "loginSecret_DESC";

export type ClubOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "masterId_ASC"
  | "masterId_DESC"
  | "name_ASC"
  | "name_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "description_ASC"
  | "description_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "clubImage_ASC"
  | "clubImage_DESC"
  | "type_ASC"
  | "type_DESC"
  | "socialUrl_ASC"
  | "socialUrl_DESC"
  | "socialDisplay_ASC"
  | "socialDisplay_DESC";

export type ApplicationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "checked_ASC"
  | "checked_DESC"
  | "isPass_ASC"
  | "isPass_DESC";

export type RoomOrderByInput = "id_ASC" | "id_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC";

export type NotificationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "content_ASC"
  | "content_DESC"
  | "checked_ASC"
  | "checked_DESC";

export type QuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "subject_ASC"
  | "subject_DESC"
  | "type_ASC"
  | "type_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ApplicationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  encryptedPassword_not?: Maybe<String>;
  encryptedPassword_in?: Maybe<String[] | String>;
  encryptedPassword_not_in?: Maybe<String[] | String>;
  encryptedPassword_lt?: Maybe<String>;
  encryptedPassword_lte?: Maybe<String>;
  encryptedPassword_gt?: Maybe<String>;
  encryptedPassword_gte?: Maybe<String>;
  encryptedPassword_contains?: Maybe<String>;
  encryptedPassword_not_contains?: Maybe<String>;
  encryptedPassword_starts_with?: Maybe<String>;
  encryptedPassword_not_starts_with?: Maybe<String>;
  encryptedPassword_ends_with?: Maybe<String>;
  encryptedPassword_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  studentNumber_not?: Maybe<Int>;
  studentNumber_in?: Maybe<Int[] | Int>;
  studentNumber_not_in?: Maybe<Int[] | Int>;
  studentNumber_lt?: Maybe<Int>;
  studentNumber_lte?: Maybe<Int>;
  studentNumber_gt?: Maybe<Int>;
  studentNumber_gte?: Maybe<Int>;
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  isMaster?: Maybe<String>;
  isMaster_not?: Maybe<String>;
  isMaster_in?: Maybe<String[] | String>;
  isMaster_not_in?: Maybe<String[] | String>;
  isMaster_lt?: Maybe<String>;
  isMaster_lte?: Maybe<String>;
  isMaster_gt?: Maybe<String>;
  isMaster_gte?: Maybe<String>;
  isMaster_contains?: Maybe<String>;
  isMaster_not_contains?: Maybe<String>;
  isMaster_starts_with?: Maybe<String>;
  isMaster_not_starts_with?: Maybe<String>;
  isMaster_ends_with?: Maybe<String>;
  isMaster_not_ends_with?: Maybe<String>;
  sex?: Maybe<String>;
  sex_not?: Maybe<String>;
  sex_in?: Maybe<String[] | String>;
  sex_not_in?: Maybe<String[] | String>;
  sex_lt?: Maybe<String>;
  sex_lte?: Maybe<String>;
  sex_gt?: Maybe<String>;
  sex_gte?: Maybe<String>;
  sex_contains?: Maybe<String>;
  sex_not_contains?: Maybe<String>;
  sex_starts_with?: Maybe<String>;
  sex_not_starts_with?: Maybe<String>;
  sex_ends_with?: Maybe<String>;
  sex_not_ends_with?: Maybe<String>;
  joinClubs_every?: Maybe<ClubWhereInput>;
  joinClubs_some?: Maybe<ClubWhereInput>;
  joinClubs_none?: Maybe<ClubWhereInput>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  rooms_every?: Maybe<RoomWhereInput>;
  rooms_some?: Maybe<RoomWhereInput>;
  rooms_none?: Maybe<RoomWhereInput>;
  notifications_every?: Maybe<NotificationWhereInput>;
  notifications_some?: Maybe<NotificationWhereInput>;
  notifications_none?: Maybe<NotificationWhereInput>;
  loginSecret?: Maybe<String>;
  loginSecret_not?: Maybe<String>;
  loginSecret_in?: Maybe<String[] | String>;
  loginSecret_not_in?: Maybe<String[] | String>;
  loginSecret_lt?: Maybe<String>;
  loginSecret_lte?: Maybe<String>;
  loginSecret_gt?: Maybe<String>;
  loginSecret_gte?: Maybe<String>;
  loginSecret_contains?: Maybe<String>;
  loginSecret_not_contains?: Maybe<String>;
  loginSecret_starts_with?: Maybe<String>;
  loginSecret_not_starts_with?: Maybe<String>;
  loginSecret_ends_with?: Maybe<String>;
  loginSecret_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ClubWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  masterId?: Maybe<Int>;
  masterId_not?: Maybe<Int>;
  masterId_in?: Maybe<Int[] | Int>;
  masterId_not_in?: Maybe<Int[] | Int>;
  masterId_lt?: Maybe<Int>;
  masterId_lte?: Maybe<Int>;
  masterId_gt?: Maybe<Int>;
  masterId_gte?: Maybe<Int>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  applications_every?: Maybe<ApplicationWhereInput>;
  applications_some?: Maybe<ApplicationWhereInput>;
  applications_none?: Maybe<ApplicationWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  clubImage?: Maybe<String>;
  clubImage_not?: Maybe<String>;
  clubImage_in?: Maybe<String[] | String>;
  clubImage_not_in?: Maybe<String[] | String>;
  clubImage_lt?: Maybe<String>;
  clubImage_lte?: Maybe<String>;
  clubImage_gt?: Maybe<String>;
  clubImage_gte?: Maybe<String>;
  clubImage_contains?: Maybe<String>;
  clubImage_not_contains?: Maybe<String>;
  clubImage_starts_with?: Maybe<String>;
  clubImage_not_starts_with?: Maybe<String>;
  clubImage_ends_with?: Maybe<String>;
  clubImage_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  socialUrl?: Maybe<String>;
  socialUrl_not?: Maybe<String>;
  socialUrl_in?: Maybe<String[] | String>;
  socialUrl_not_in?: Maybe<String[] | String>;
  socialUrl_lt?: Maybe<String>;
  socialUrl_lte?: Maybe<String>;
  socialUrl_gt?: Maybe<String>;
  socialUrl_gte?: Maybe<String>;
  socialUrl_contains?: Maybe<String>;
  socialUrl_not_contains?: Maybe<String>;
  socialUrl_starts_with?: Maybe<String>;
  socialUrl_not_starts_with?: Maybe<String>;
  socialUrl_ends_with?: Maybe<String>;
  socialUrl_not_ends_with?: Maybe<String>;
  socialDisplay?: Maybe<Boolean>;
  socialDisplay_not?: Maybe<Boolean>;
  AND?: Maybe<ClubWhereInput[] | ClubWhereInput>;
  OR?: Maybe<ClubWhereInput[] | ClubWhereInput>;
  NOT?: Maybe<ClubWhereInput[] | ClubWhereInput>;
}

export interface ApplicationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<Int>;
  userId_not?: Maybe<Int>;
  userId_in?: Maybe<Int[] | Int>;
  userId_not_in?: Maybe<Int[] | Int>;
  userId_lt?: Maybe<Int>;
  userId_lte?: Maybe<Int>;
  userId_gt?: Maybe<Int>;
  userId_gte?: Maybe<Int>;
  club?: Maybe<ClubWhereInput>;
  questions_every?: Maybe<QuestionWhereInput>;
  questions_some?: Maybe<QuestionWhereInput>;
  questions_none?: Maybe<QuestionWhereInput>;
  checked?: Maybe<Boolean>;
  checked_not?: Maybe<Boolean>;
  isPass?: Maybe<Boolean>;
  isPass_not?: Maybe<Boolean>;
  AND?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  OR?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
  NOT?: Maybe<ApplicationWhereInput[] | ApplicationWhereInput>;
}

export interface QuestionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subject?: Maybe<String>;
  subject_not?: Maybe<String>;
  subject_in?: Maybe<String[] | String>;
  subject_not_in?: Maybe<String[] | String>;
  subject_lt?: Maybe<String>;
  subject_lte?: Maybe<String>;
  subject_gt?: Maybe<String>;
  subject_gte?: Maybe<String>;
  subject_contains?: Maybe<String>;
  subject_not_contains?: Maybe<String>;
  subject_starts_with?: Maybe<String>;
  subject_not_starts_with?: Maybe<String>;
  subject_ends_with?: Maybe<String>;
  subject_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  OR?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  NOT?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
}

export interface RoomWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  participants_every?: Maybe<UserWhereInput>;
  participants_some?: Maybe<UserWhereInput>;
  participants_none?: Maybe<UserWhereInput>;
  messages_every?: Maybe<MessageWhereInput>;
  messages_some?: Maybe<MessageWhereInput>;
  messages_none?: Maybe<MessageWhereInput>;
  AND?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  OR?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  NOT?: Maybe<RoomWhereInput[] | RoomWhereInput>;
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  from?: Maybe<UserWhereInput>;
  to?: Maybe<UserWhereInput>;
  room?: Maybe<RoomWhereInput>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export interface NotificationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<Int>;
  userId_not?: Maybe<Int>;
  userId_in?: Maybe<Int[] | Int>;
  userId_not_in?: Maybe<Int[] | Int>;
  userId_lt?: Maybe<Int>;
  userId_lte?: Maybe<Int>;
  userId_gt?: Maybe<Int>;
  userId_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  checked?: Maybe<Boolean>;
  checked_not?: Maybe<Boolean>;
  AND?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  OR?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
  NOT?: Maybe<NotificationWhereInput[] | NotificationWhereInput>;
}

export type ClubWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type NotificationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuestionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type RoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ApplicationCreateInput {
  id?: Maybe<ID_Input>;
  userId: Int;
  club: ClubCreateOneWithoutApplicationsInput;
  questions?: Maybe<QuestionCreateManyInput>;
  answer?: Maybe<ApplicationCreateanswerInput>;
  checked: Boolean;
  isPass?: Maybe<Boolean>;
}

export interface ClubCreateOneWithoutApplicationsInput {
  create?: Maybe<ClubCreateWithoutApplicationsInput>;
  connect?: Maybe<ClubWhereUniqueInput>;
}

export interface ClubCreateWithoutApplicationsInput {
  id?: Maybe<ID_Input>;
  masterId: Int;
  members?: Maybe<UserCreateManyWithoutJoinClubsInput>;
  name: String;
  bio: String;
  description: String;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type: String;
  socialUrl: String;
  socialDisplay: Boolean;
}

export interface UserCreateManyWithoutJoinClubsInput {
  create?: Maybe<
    UserCreateWithoutJoinClubsInput[] | UserCreateWithoutJoinClubsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutJoinClubsInput {
  id?: Maybe<ID_Input>;
  email: String;
  encryptedPassword: String;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  applications?: Maybe<ApplicationCreateManyInput>;
  rooms?: Maybe<RoomCreateManyWithoutParticipantsInput>;
  notifications?: Maybe<NotificationCreateManyInput>;
  loginSecret?: Maybe<String>;
}

export interface ApplicationCreateManyInput {
  create?: Maybe<ApplicationCreateInput[] | ApplicationCreateInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface RoomCreateManyWithoutParticipantsInput {
  create?: Maybe<
    RoomCreateWithoutParticipantsInput[] | RoomCreateWithoutParticipantsInput
  >;
  connect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
}

export interface RoomCreateWithoutParticipantsInput {
  id?: Maybe<ID_Input>;
  messages?: Maybe<MessageCreateManyWithoutRoomInput>;
}

export interface MessageCreateManyWithoutRoomInput {
  create?: Maybe<
    MessageCreateWithoutRoomInput[] | MessageCreateWithoutRoomInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutRoomInput {
  id?: Maybe<ID_Input>;
  text: String;
  from: UserCreateOneInput;
  to: UserCreateOneInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  encryptedPassword: String;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  joinClubs?: Maybe<ClubCreateManyWithoutMembersInput>;
  applications?: Maybe<ApplicationCreateManyInput>;
  rooms?: Maybe<RoomCreateManyWithoutParticipantsInput>;
  notifications?: Maybe<NotificationCreateManyInput>;
  loginSecret?: Maybe<String>;
}

export interface ClubCreateManyWithoutMembersInput {
  create?: Maybe<
    ClubCreateWithoutMembersInput[] | ClubCreateWithoutMembersInput
  >;
  connect?: Maybe<ClubWhereUniqueInput[] | ClubWhereUniqueInput>;
}

export interface ClubCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  masterId: Int;
  applications?: Maybe<ApplicationCreateManyWithoutClubInput>;
  name: String;
  bio: String;
  description: String;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type: String;
  socialUrl: String;
  socialDisplay: Boolean;
}

export interface ApplicationCreateManyWithoutClubInput {
  create?: Maybe<
    ApplicationCreateWithoutClubInput[] | ApplicationCreateWithoutClubInput
  >;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
}

export interface ApplicationCreateWithoutClubInput {
  id?: Maybe<ID_Input>;
  userId: Int;
  questions?: Maybe<QuestionCreateManyInput>;
  answer?: Maybe<ApplicationCreateanswerInput>;
  checked: Boolean;
  isPass?: Maybe<Boolean>;
}

export interface QuestionCreateManyInput {
  create?: Maybe<QuestionCreateInput[] | QuestionCreateInput>;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
}

export interface QuestionCreateInput {
  id?: Maybe<ID_Input>;
  subject?: Maybe<String>;
  type?: Maybe<String>;
  options?: Maybe<QuestionCreateoptionsInput>;
}

export interface QuestionCreateoptionsInput {
  set?: Maybe<String[] | String>;
}

export interface ApplicationCreateanswerInput {
  set?: Maybe<String[] | String>;
}

export interface NotificationCreateManyInput {
  create?: Maybe<NotificationCreateInput[] | NotificationCreateInput>;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
}

export interface NotificationCreateInput {
  id?: Maybe<ID_Input>;
  userId: Int;
  content: String;
  checked: Boolean;
}

export interface ApplicationUpdateInput {
  userId?: Maybe<Int>;
  club?: Maybe<ClubUpdateOneRequiredWithoutApplicationsInput>;
  questions?: Maybe<QuestionUpdateManyInput>;
  answer?: Maybe<ApplicationUpdateanswerInput>;
  checked?: Maybe<Boolean>;
  isPass?: Maybe<Boolean>;
}

export interface ClubUpdateOneRequiredWithoutApplicationsInput {
  create?: Maybe<ClubCreateWithoutApplicationsInput>;
  update?: Maybe<ClubUpdateWithoutApplicationsDataInput>;
  upsert?: Maybe<ClubUpsertWithoutApplicationsInput>;
  connect?: Maybe<ClubWhereUniqueInput>;
}

export interface ClubUpdateWithoutApplicationsDataInput {
  masterId?: Maybe<Int>;
  members?: Maybe<UserUpdateManyWithoutJoinClubsInput>;
  name?: Maybe<String>;
  bio?: Maybe<String>;
  description?: Maybe<String>;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type?: Maybe<String>;
  socialUrl?: Maybe<String>;
  socialDisplay?: Maybe<Boolean>;
}

export interface UserUpdateManyWithoutJoinClubsInput {
  create?: Maybe<
    UserCreateWithoutJoinClubsInput[] | UserCreateWithoutJoinClubsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutJoinClubsInput[]
    | UserUpdateWithWhereUniqueWithoutJoinClubsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutJoinClubsInput[]
    | UserUpsertWithWhereUniqueWithoutJoinClubsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutJoinClubsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutJoinClubsDataInput;
}

export interface UserUpdateWithoutJoinClubsDataInput {
  email?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  applications?: Maybe<ApplicationUpdateManyInput>;
  rooms?: Maybe<RoomUpdateManyWithoutParticipantsInput>;
  notifications?: Maybe<NotificationUpdateManyInput>;
  loginSecret?: Maybe<String>;
}

export interface ApplicationUpdateManyInput {
  create?: Maybe<ApplicationCreateInput[] | ApplicationCreateInput>;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueNestedInput[]
    | ApplicationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueNestedInput[]
    | ApplicationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationUpdateWithWhereUniqueNestedInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateDataInput;
}

export interface ApplicationUpdateDataInput {
  userId?: Maybe<Int>;
  club?: Maybe<ClubUpdateOneRequiredWithoutApplicationsInput>;
  questions?: Maybe<QuestionUpdateManyInput>;
  answer?: Maybe<ApplicationUpdateanswerInput>;
  checked?: Maybe<Boolean>;
  isPass?: Maybe<Boolean>;
}

export interface QuestionUpdateManyInput {
  create?: Maybe<QuestionCreateInput[] | QuestionCreateInput>;
  update?: Maybe<
    | QuestionUpdateWithWhereUniqueNestedInput[]
    | QuestionUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | QuestionUpsertWithWhereUniqueNestedInput[]
    | QuestionUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  connect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  set?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  disconnect?: Maybe<QuestionWhereUniqueInput[] | QuestionWhereUniqueInput>;
  deleteMany?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  updateMany?: Maybe<
    | QuestionUpdateManyWithWhereNestedInput[]
    | QuestionUpdateManyWithWhereNestedInput
  >;
}

export interface QuestionUpdateWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  data: QuestionUpdateDataInput;
}

export interface QuestionUpdateDataInput {
  subject?: Maybe<String>;
  type?: Maybe<String>;
  options?: Maybe<QuestionUpdateoptionsInput>;
}

export interface QuestionUpdateoptionsInput {
  set?: Maybe<String[] | String>;
}

export interface QuestionUpsertWithWhereUniqueNestedInput {
  where: QuestionWhereUniqueInput;
  update: QuestionUpdateDataInput;
  create: QuestionCreateInput;
}

export interface QuestionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  subject?: Maybe<String>;
  subject_not?: Maybe<String>;
  subject_in?: Maybe<String[] | String>;
  subject_not_in?: Maybe<String[] | String>;
  subject_lt?: Maybe<String>;
  subject_lte?: Maybe<String>;
  subject_gt?: Maybe<String>;
  subject_gte?: Maybe<String>;
  subject_contains?: Maybe<String>;
  subject_not_contains?: Maybe<String>;
  subject_starts_with?: Maybe<String>;
  subject_not_starts_with?: Maybe<String>;
  subject_ends_with?: Maybe<String>;
  subject_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  OR?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
  NOT?: Maybe<QuestionScalarWhereInput[] | QuestionScalarWhereInput>;
}

export interface QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput;
  data: QuestionUpdateManyDataInput;
}

export interface QuestionUpdateManyDataInput {
  subject?: Maybe<String>;
  type?: Maybe<String>;
  options?: Maybe<QuestionUpdateoptionsInput>;
}

export interface ApplicationUpdateanswerInput {
  set?: Maybe<String[] | String>;
}

export interface ApplicationUpsertWithWhereUniqueNestedInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateDataInput;
  create: ApplicationCreateInput;
}

export interface ApplicationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<Int>;
  userId_not?: Maybe<Int>;
  userId_in?: Maybe<Int[] | Int>;
  userId_not_in?: Maybe<Int[] | Int>;
  userId_lt?: Maybe<Int>;
  userId_lte?: Maybe<Int>;
  userId_gt?: Maybe<Int>;
  userId_gte?: Maybe<Int>;
  checked?: Maybe<Boolean>;
  checked_not?: Maybe<Boolean>;
  isPass?: Maybe<Boolean>;
  isPass_not?: Maybe<Boolean>;
  AND?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  OR?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
  NOT?: Maybe<ApplicationScalarWhereInput[] | ApplicationScalarWhereInput>;
}

export interface ApplicationUpdateManyWithWhereNestedInput {
  where: ApplicationScalarWhereInput;
  data: ApplicationUpdateManyDataInput;
}

export interface ApplicationUpdateManyDataInput {
  userId?: Maybe<Int>;
  answer?: Maybe<ApplicationUpdateanswerInput>;
  checked?: Maybe<Boolean>;
  isPass?: Maybe<Boolean>;
}

export interface RoomUpdateManyWithoutParticipantsInput {
  create?: Maybe<
    RoomCreateWithoutParticipantsInput[] | RoomCreateWithoutParticipantsInput
  >;
  delete?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  connect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  set?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  disconnect?: Maybe<RoomWhereUniqueInput[] | RoomWhereUniqueInput>;
  update?: Maybe<
    | RoomUpdateWithWhereUniqueWithoutParticipantsInput[]
    | RoomUpdateWithWhereUniqueWithoutParticipantsInput
  >;
  upsert?: Maybe<
    | RoomUpsertWithWhereUniqueWithoutParticipantsInput[]
    | RoomUpsertWithWhereUniqueWithoutParticipantsInput
  >;
  deleteMany?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
}

export interface RoomUpdateWithWhereUniqueWithoutParticipantsInput {
  where: RoomWhereUniqueInput;
  data: RoomUpdateWithoutParticipantsDataInput;
}

export interface RoomUpdateWithoutParticipantsDataInput {
  messages?: Maybe<MessageUpdateManyWithoutRoomInput>;
}

export interface MessageUpdateManyWithoutRoomInput {
  create?: Maybe<
    MessageCreateWithoutRoomInput[] | MessageCreateWithoutRoomInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutRoomInput[]
    | MessageUpdateWithWhereUniqueWithoutRoomInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutRoomInput[]
    | MessageUpsertWithWhereUniqueWithoutRoomInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutRoomInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutRoomDataInput;
}

export interface MessageUpdateWithoutRoomDataInput {
  text?: Maybe<String>;
  from?: Maybe<UserUpdateOneRequiredInput>;
  to?: Maybe<UserUpdateOneRequiredInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  joinClubs?: Maybe<ClubUpdateManyWithoutMembersInput>;
  applications?: Maybe<ApplicationUpdateManyInput>;
  rooms?: Maybe<RoomUpdateManyWithoutParticipantsInput>;
  notifications?: Maybe<NotificationUpdateManyInput>;
  loginSecret?: Maybe<String>;
}

export interface ClubUpdateManyWithoutMembersInput {
  create?: Maybe<
    ClubCreateWithoutMembersInput[] | ClubCreateWithoutMembersInput
  >;
  delete?: Maybe<ClubWhereUniqueInput[] | ClubWhereUniqueInput>;
  connect?: Maybe<ClubWhereUniqueInput[] | ClubWhereUniqueInput>;
  set?: Maybe<ClubWhereUniqueInput[] | ClubWhereUniqueInput>;
  disconnect?: Maybe<ClubWhereUniqueInput[] | ClubWhereUniqueInput>;
  update?: Maybe<
    | ClubUpdateWithWhereUniqueWithoutMembersInput[]
    | ClubUpdateWithWhereUniqueWithoutMembersInput
  >;
  upsert?: Maybe<
    | ClubUpsertWithWhereUniqueWithoutMembersInput[]
    | ClubUpsertWithWhereUniqueWithoutMembersInput
  >;
  deleteMany?: Maybe<ClubScalarWhereInput[] | ClubScalarWhereInput>;
  updateMany?: Maybe<
    ClubUpdateManyWithWhereNestedInput[] | ClubUpdateManyWithWhereNestedInput
  >;
}

export interface ClubUpdateWithWhereUniqueWithoutMembersInput {
  where: ClubWhereUniqueInput;
  data: ClubUpdateWithoutMembersDataInput;
}

export interface ClubUpdateWithoutMembersDataInput {
  masterId?: Maybe<Int>;
  applications?: Maybe<ApplicationUpdateManyWithoutClubInput>;
  name?: Maybe<String>;
  bio?: Maybe<String>;
  description?: Maybe<String>;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type?: Maybe<String>;
  socialUrl?: Maybe<String>;
  socialDisplay?: Maybe<Boolean>;
}

export interface ApplicationUpdateManyWithoutClubInput {
  create?: Maybe<
    ApplicationCreateWithoutClubInput[] | ApplicationCreateWithoutClubInput
  >;
  delete?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  connect?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  set?: Maybe<ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput>;
  disconnect?: Maybe<
    ApplicationWhereUniqueInput[] | ApplicationWhereUniqueInput
  >;
  update?: Maybe<
    | ApplicationUpdateWithWhereUniqueWithoutClubInput[]
    | ApplicationUpdateWithWhereUniqueWithoutClubInput
  >;
  upsert?: Maybe<
    | ApplicationUpsertWithWhereUniqueWithoutClubInput[]
    | ApplicationUpsertWithWhereUniqueWithoutClubInput
  >;
  deleteMany?: Maybe<
    ApplicationScalarWhereInput[] | ApplicationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ApplicationUpdateManyWithWhereNestedInput[]
    | ApplicationUpdateManyWithWhereNestedInput
  >;
}

export interface ApplicationUpdateWithWhereUniqueWithoutClubInput {
  where: ApplicationWhereUniqueInput;
  data: ApplicationUpdateWithoutClubDataInput;
}

export interface ApplicationUpdateWithoutClubDataInput {
  userId?: Maybe<Int>;
  questions?: Maybe<QuestionUpdateManyInput>;
  answer?: Maybe<ApplicationUpdateanswerInput>;
  checked?: Maybe<Boolean>;
  isPass?: Maybe<Boolean>;
}

export interface ApplicationUpsertWithWhereUniqueWithoutClubInput {
  where: ApplicationWhereUniqueInput;
  update: ApplicationUpdateWithoutClubDataInput;
  create: ApplicationCreateWithoutClubInput;
}

export interface ClubUpsertWithWhereUniqueWithoutMembersInput {
  where: ClubWhereUniqueInput;
  update: ClubUpdateWithoutMembersDataInput;
  create: ClubCreateWithoutMembersInput;
}

export interface ClubScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  masterId?: Maybe<Int>;
  masterId_not?: Maybe<Int>;
  masterId_in?: Maybe<Int[] | Int>;
  masterId_not_in?: Maybe<Int[] | Int>;
  masterId_lt?: Maybe<Int>;
  masterId_lte?: Maybe<Int>;
  masterId_gt?: Maybe<Int>;
  masterId_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  clubImage?: Maybe<String>;
  clubImage_not?: Maybe<String>;
  clubImage_in?: Maybe<String[] | String>;
  clubImage_not_in?: Maybe<String[] | String>;
  clubImage_lt?: Maybe<String>;
  clubImage_lte?: Maybe<String>;
  clubImage_gt?: Maybe<String>;
  clubImage_gte?: Maybe<String>;
  clubImage_contains?: Maybe<String>;
  clubImage_not_contains?: Maybe<String>;
  clubImage_starts_with?: Maybe<String>;
  clubImage_not_starts_with?: Maybe<String>;
  clubImage_ends_with?: Maybe<String>;
  clubImage_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  socialUrl?: Maybe<String>;
  socialUrl_not?: Maybe<String>;
  socialUrl_in?: Maybe<String[] | String>;
  socialUrl_not_in?: Maybe<String[] | String>;
  socialUrl_lt?: Maybe<String>;
  socialUrl_lte?: Maybe<String>;
  socialUrl_gt?: Maybe<String>;
  socialUrl_gte?: Maybe<String>;
  socialUrl_contains?: Maybe<String>;
  socialUrl_not_contains?: Maybe<String>;
  socialUrl_starts_with?: Maybe<String>;
  socialUrl_not_starts_with?: Maybe<String>;
  socialUrl_ends_with?: Maybe<String>;
  socialUrl_not_ends_with?: Maybe<String>;
  socialDisplay?: Maybe<Boolean>;
  socialDisplay_not?: Maybe<Boolean>;
  AND?: Maybe<ClubScalarWhereInput[] | ClubScalarWhereInput>;
  OR?: Maybe<ClubScalarWhereInput[] | ClubScalarWhereInput>;
  NOT?: Maybe<ClubScalarWhereInput[] | ClubScalarWhereInput>;
}

export interface ClubUpdateManyWithWhereNestedInput {
  where: ClubScalarWhereInput;
  data: ClubUpdateManyDataInput;
}

export interface ClubUpdateManyDataInput {
  masterId?: Maybe<Int>;
  name?: Maybe<String>;
  bio?: Maybe<String>;
  description?: Maybe<String>;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type?: Maybe<String>;
  socialUrl?: Maybe<String>;
  socialDisplay?: Maybe<Boolean>;
}

export interface NotificationUpdateManyInput {
  create?: Maybe<NotificationCreateInput[] | NotificationCreateInput>;
  update?: Maybe<
    | NotificationUpdateWithWhereUniqueNestedInput[]
    | NotificationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | NotificationUpsertWithWhereUniqueNestedInput[]
    | NotificationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  connect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  set?: Maybe<NotificationWhereUniqueInput[] | NotificationWhereUniqueInput>;
  disconnect?: Maybe<
    NotificationWhereUniqueInput[] | NotificationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    NotificationScalarWhereInput[] | NotificationScalarWhereInput
  >;
  updateMany?: Maybe<
    | NotificationUpdateManyWithWhereNestedInput[]
    | NotificationUpdateManyWithWhereNestedInput
  >;
}

export interface NotificationUpdateWithWhereUniqueNestedInput {
  where: NotificationWhereUniqueInput;
  data: NotificationUpdateDataInput;
}

export interface NotificationUpdateDataInput {
  userId?: Maybe<Int>;
  content?: Maybe<String>;
  checked?: Maybe<Boolean>;
}

export interface NotificationUpsertWithWhereUniqueNestedInput {
  where: NotificationWhereUniqueInput;
  update: NotificationUpdateDataInput;
  create: NotificationCreateInput;
}

export interface NotificationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  userId?: Maybe<Int>;
  userId_not?: Maybe<Int>;
  userId_in?: Maybe<Int[] | Int>;
  userId_not_in?: Maybe<Int[] | Int>;
  userId_lt?: Maybe<Int>;
  userId_lte?: Maybe<Int>;
  userId_gt?: Maybe<Int>;
  userId_gte?: Maybe<Int>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  checked?: Maybe<Boolean>;
  checked_not?: Maybe<Boolean>;
  AND?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  OR?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
  NOT?: Maybe<NotificationScalarWhereInput[] | NotificationScalarWhereInput>;
}

export interface NotificationUpdateManyWithWhereNestedInput {
  where: NotificationScalarWhereInput;
  data: NotificationUpdateManyDataInput;
}

export interface NotificationUpdateManyDataInput {
  userId?: Maybe<Int>;
  content?: Maybe<String>;
  checked?: Maybe<Boolean>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface MessageUpsertWithWhereUniqueWithoutRoomInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutRoomDataInput;
  create: MessageCreateWithoutRoomInput;
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyDataInput {
  text?: Maybe<String>;
}

export interface RoomUpsertWithWhereUniqueWithoutParticipantsInput {
  where: RoomWhereUniqueInput;
  update: RoomUpdateWithoutParticipantsDataInput;
  create: RoomCreateWithoutParticipantsInput;
}

export interface RoomScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  OR?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
  NOT?: Maybe<RoomScalarWhereInput[] | RoomScalarWhereInput>;
}

export interface UserUpsertWithWhereUniqueWithoutJoinClubsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutJoinClubsDataInput;
  create: UserCreateWithoutJoinClubsInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  encryptedPassword_not?: Maybe<String>;
  encryptedPassword_in?: Maybe<String[] | String>;
  encryptedPassword_not_in?: Maybe<String[] | String>;
  encryptedPassword_lt?: Maybe<String>;
  encryptedPassword_lte?: Maybe<String>;
  encryptedPassword_gt?: Maybe<String>;
  encryptedPassword_gte?: Maybe<String>;
  encryptedPassword_contains?: Maybe<String>;
  encryptedPassword_not_contains?: Maybe<String>;
  encryptedPassword_starts_with?: Maybe<String>;
  encryptedPassword_not_starts_with?: Maybe<String>;
  encryptedPassword_ends_with?: Maybe<String>;
  encryptedPassword_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  studentNumber_not?: Maybe<Int>;
  studentNumber_in?: Maybe<Int[] | Int>;
  studentNumber_not_in?: Maybe<Int[] | Int>;
  studentNumber_lt?: Maybe<Int>;
  studentNumber_lte?: Maybe<Int>;
  studentNumber_gt?: Maybe<Int>;
  studentNumber_gte?: Maybe<Int>;
  Name?: Maybe<String>;
  Name_not?: Maybe<String>;
  Name_in?: Maybe<String[] | String>;
  Name_not_in?: Maybe<String[] | String>;
  Name_lt?: Maybe<String>;
  Name_lte?: Maybe<String>;
  Name_gt?: Maybe<String>;
  Name_gte?: Maybe<String>;
  Name_contains?: Maybe<String>;
  Name_not_contains?: Maybe<String>;
  Name_starts_with?: Maybe<String>;
  Name_not_starts_with?: Maybe<String>;
  Name_ends_with?: Maybe<String>;
  Name_not_ends_with?: Maybe<String>;
  isMaster?: Maybe<String>;
  isMaster_not?: Maybe<String>;
  isMaster_in?: Maybe<String[] | String>;
  isMaster_not_in?: Maybe<String[] | String>;
  isMaster_lt?: Maybe<String>;
  isMaster_lte?: Maybe<String>;
  isMaster_gt?: Maybe<String>;
  isMaster_gte?: Maybe<String>;
  isMaster_contains?: Maybe<String>;
  isMaster_not_contains?: Maybe<String>;
  isMaster_starts_with?: Maybe<String>;
  isMaster_not_starts_with?: Maybe<String>;
  isMaster_ends_with?: Maybe<String>;
  isMaster_not_ends_with?: Maybe<String>;
  sex?: Maybe<String>;
  sex_not?: Maybe<String>;
  sex_in?: Maybe<String[] | String>;
  sex_not_in?: Maybe<String[] | String>;
  sex_lt?: Maybe<String>;
  sex_lte?: Maybe<String>;
  sex_gt?: Maybe<String>;
  sex_gte?: Maybe<String>;
  sex_contains?: Maybe<String>;
  sex_not_contains?: Maybe<String>;
  sex_starts_with?: Maybe<String>;
  sex_not_starts_with?: Maybe<String>;
  sex_ends_with?: Maybe<String>;
  sex_not_ends_with?: Maybe<String>;
  loginSecret?: Maybe<String>;
  loginSecret_not?: Maybe<String>;
  loginSecret_in?: Maybe<String[] | String>;
  loginSecret_not_in?: Maybe<String[] | String>;
  loginSecret_lt?: Maybe<String>;
  loginSecret_lte?: Maybe<String>;
  loginSecret_gt?: Maybe<String>;
  loginSecret_gte?: Maybe<String>;
  loginSecret_contains?: Maybe<String>;
  loginSecret_not_contains?: Maybe<String>;
  loginSecret_starts_with?: Maybe<String>;
  loginSecret_not_starts_with?: Maybe<String>;
  loginSecret_ends_with?: Maybe<String>;
  loginSecret_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  loginSecret?: Maybe<String>;
}

export interface ClubUpsertWithoutApplicationsInput {
  update: ClubUpdateWithoutApplicationsDataInput;
  create: ClubCreateWithoutApplicationsInput;
}

export interface ApplicationUpdateManyMutationInput {
  userId?: Maybe<Int>;
  answer?: Maybe<ApplicationUpdateanswerInput>;
  checked?: Maybe<Boolean>;
  isPass?: Maybe<Boolean>;
}

export interface ClubCreateInput {
  id?: Maybe<ID_Input>;
  masterId: Int;
  members?: Maybe<UserCreateManyWithoutJoinClubsInput>;
  applications?: Maybe<ApplicationCreateManyWithoutClubInput>;
  name: String;
  bio: String;
  description: String;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type: String;
  socialUrl: String;
  socialDisplay: Boolean;
}

export interface ClubUpdateInput {
  masterId?: Maybe<Int>;
  members?: Maybe<UserUpdateManyWithoutJoinClubsInput>;
  applications?: Maybe<ApplicationUpdateManyWithoutClubInput>;
  name?: Maybe<String>;
  bio?: Maybe<String>;
  description?: Maybe<String>;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type?: Maybe<String>;
  socialUrl?: Maybe<String>;
  socialDisplay?: Maybe<Boolean>;
}

export interface ClubUpdateManyMutationInput {
  masterId?: Maybe<Int>;
  name?: Maybe<String>;
  bio?: Maybe<String>;
  description?: Maybe<String>;
  logo?: Maybe<String>;
  clubImage?: Maybe<String>;
  type?: Maybe<String>;
  socialUrl?: Maybe<String>;
  socialDisplay?: Maybe<Boolean>;
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  from: UserCreateOneInput;
  to: UserCreateOneInput;
  room: RoomCreateOneWithoutMessagesInput;
}

export interface RoomCreateOneWithoutMessagesInput {
  create?: Maybe<RoomCreateWithoutMessagesInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface RoomCreateWithoutMessagesInput {
  id?: Maybe<ID_Input>;
  participants?: Maybe<UserCreateManyWithoutRoomsInput>;
}

export interface UserCreateManyWithoutRoomsInput {
  create?: Maybe<UserCreateWithoutRoomsInput[] | UserCreateWithoutRoomsInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutRoomsInput {
  id?: Maybe<ID_Input>;
  email: String;
  encryptedPassword: String;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  joinClubs?: Maybe<ClubCreateManyWithoutMembersInput>;
  applications?: Maybe<ApplicationCreateManyInput>;
  notifications?: Maybe<NotificationCreateManyInput>;
  loginSecret?: Maybe<String>;
}

export interface MessageUpdateInput {
  text?: Maybe<String>;
  from?: Maybe<UserUpdateOneRequiredInput>;
  to?: Maybe<UserUpdateOneRequiredInput>;
  room?: Maybe<RoomUpdateOneRequiredWithoutMessagesInput>;
}

export interface RoomUpdateOneRequiredWithoutMessagesInput {
  create?: Maybe<RoomCreateWithoutMessagesInput>;
  update?: Maybe<RoomUpdateWithoutMessagesDataInput>;
  upsert?: Maybe<RoomUpsertWithoutMessagesInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface RoomUpdateWithoutMessagesDataInput {
  participants?: Maybe<UserUpdateManyWithoutRoomsInput>;
}

export interface UserUpdateManyWithoutRoomsInput {
  create?: Maybe<UserCreateWithoutRoomsInput[] | UserCreateWithoutRoomsInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutRoomsInput[]
    | UserUpdateWithWhereUniqueWithoutRoomsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutRoomsInput[]
    | UserUpsertWithWhereUniqueWithoutRoomsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutRoomsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutRoomsDataInput;
}

export interface UserUpdateWithoutRoomsDataInput {
  email?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  joinClubs?: Maybe<ClubUpdateManyWithoutMembersInput>;
  applications?: Maybe<ApplicationUpdateManyInput>;
  notifications?: Maybe<NotificationUpdateManyInput>;
  loginSecret?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutRoomsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutRoomsDataInput;
  create: UserCreateWithoutRoomsInput;
}

export interface RoomUpsertWithoutMessagesInput {
  update: RoomUpdateWithoutMessagesDataInput;
  create: RoomCreateWithoutMessagesInput;
}

export interface MessageUpdateManyMutationInput {
  text?: Maybe<String>;
}

export interface NotificationUpdateInput {
  userId?: Maybe<Int>;
  content?: Maybe<String>;
  checked?: Maybe<Boolean>;
}

export interface NotificationUpdateManyMutationInput {
  userId?: Maybe<Int>;
  content?: Maybe<String>;
  checked?: Maybe<Boolean>;
}

export interface QuestionUpdateInput {
  subject?: Maybe<String>;
  type?: Maybe<String>;
  options?: Maybe<QuestionUpdateoptionsInput>;
}

export interface QuestionUpdateManyMutationInput {
  subject?: Maybe<String>;
  type?: Maybe<String>;
  options?: Maybe<QuestionUpdateoptionsInput>;
}

export interface RoomCreateInput {
  id?: Maybe<ID_Input>;
  participants?: Maybe<UserCreateManyWithoutRoomsInput>;
  messages?: Maybe<MessageCreateManyWithoutRoomInput>;
}

export interface RoomUpdateInput {
  participants?: Maybe<UserUpdateManyWithoutRoomsInput>;
  messages?: Maybe<MessageUpdateManyWithoutRoomInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  joinClubs?: Maybe<ClubUpdateManyWithoutMembersInput>;
  applications?: Maybe<ApplicationUpdateManyInput>;
  rooms?: Maybe<RoomUpdateManyWithoutParticipantsInput>;
  notifications?: Maybe<NotificationUpdateManyInput>;
  loginSecret?: Maybe<String>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  encryptedPassword?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  studentNumber?: Maybe<Int>;
  Name?: Maybe<String>;
  isMaster?: Maybe<String>;
  sex?: Maybe<String>;
  loginSecret?: Maybe<String>;
}

export interface ApplicationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ApplicationWhereInput>;
  AND?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  OR?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ApplicationSubscriptionWhereInput[] | ApplicationSubscriptionWhereInput
  >;
}

export interface ClubSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClubWhereInput>;
  AND?: Maybe<ClubSubscriptionWhereInput[] | ClubSubscriptionWhereInput>;
  OR?: Maybe<ClubSubscriptionWhereInput[] | ClubSubscriptionWhereInput>;
  NOT?: Maybe<ClubSubscriptionWhereInput[] | ClubSubscriptionWhereInput>;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface NotificationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NotificationWhereInput>;
  AND?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  OR?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NotificationSubscriptionWhereInput[] | NotificationSubscriptionWhereInput
  >;
}

export interface QuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionWhereInput>;
  AND?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
  OR?: Maybe<QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput>;
  NOT?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomWhereInput>;
  AND?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  OR?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  NOT?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Application {
  id: ID_Output;
  userId: Int;
  answer: String[];
  checked: Boolean;
  isPass?: Boolean;
}

export interface ApplicationPromise extends Promise<Application>, Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<Int>;
  club: <T = ClubPromise>() => T;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  answer: () => Promise<String[]>;
  checked: () => Promise<Boolean>;
  isPass: () => Promise<Boolean>;
}

export interface ApplicationSubscription
  extends Promise<AsyncIterator<Application>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<Int>>;
  club: <T = ClubSubscription>() => T;
  questions: <T = Promise<AsyncIterator<QuestionSubscription>>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  answer: () => Promise<AsyncIterator<String[]>>;
  checked: () => Promise<AsyncIterator<Boolean>>;
  isPass: () => Promise<AsyncIterator<Boolean>>;
}

export interface ApplicationNullablePromise
  extends Promise<Application | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<Int>;
  club: <T = ClubPromise>() => T;
  questions: <T = FragmentableArray<Question>>(args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  answer: () => Promise<String[]>;
  checked: () => Promise<Boolean>;
  isPass: () => Promise<Boolean>;
}

export interface Club {
  id: ID_Output;
  masterId: Int;
  name: String;
  bio: String;
  description: String;
  logo?: String;
  clubImage?: String;
  type: String;
  socialUrl: String;
  socialDisplay: Boolean;
}

export interface ClubPromise extends Promise<Club>, Fragmentable {
  id: () => Promise<ID_Output>;
  masterId: () => Promise<Int>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  bio: () => Promise<String>;
  description: () => Promise<String>;
  logo: () => Promise<String>;
  clubImage: () => Promise<String>;
  type: () => Promise<String>;
  socialUrl: () => Promise<String>;
  socialDisplay: () => Promise<Boolean>;
}

export interface ClubSubscription
  extends Promise<AsyncIterator<Club>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  masterId: () => Promise<AsyncIterator<Int>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  clubImage: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  socialUrl: () => Promise<AsyncIterator<String>>;
  socialDisplay: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClubNullablePromise
  extends Promise<Club | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  masterId: () => Promise<Int>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
  bio: () => Promise<String>;
  description: () => Promise<String>;
  logo: () => Promise<String>;
  clubImage: () => Promise<String>;
  type: () => Promise<String>;
  socialUrl: () => Promise<String>;
  socialDisplay: () => Promise<Boolean>;
}

export interface User {
  id: ID_Output;
  email: String;
  encryptedPassword: String;
  phoneNumber?: String;
  studentNumber?: Int;
  Name?: String;
  isMaster?: String;
  sex?: String;
  loginSecret?: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  encryptedPassword: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  studentNumber: () => Promise<Int>;
  Name: () => Promise<String>;
  isMaster: () => Promise<String>;
  sex: () => Promise<String>;
  joinClubs: <T = FragmentableArray<Club>>(args?: {
    where?: ClubWhereInput;
    orderBy?: ClubOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rooms: <T = FragmentableArray<Room>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  loginSecret: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  encryptedPassword: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  studentNumber: () => Promise<AsyncIterator<Int>>;
  Name: () => Promise<AsyncIterator<String>>;
  isMaster: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<String>>;
  joinClubs: <T = Promise<AsyncIterator<ClubSubscription>>>(args?: {
    where?: ClubWhereInput;
    orderBy?: ClubOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = Promise<AsyncIterator<ApplicationSubscription>>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rooms: <T = Promise<AsyncIterator<RoomSubscription>>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notifications: <T = Promise<AsyncIterator<NotificationSubscription>>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  loginSecret: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  encryptedPassword: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  studentNumber: () => Promise<Int>;
  Name: () => Promise<String>;
  isMaster: () => Promise<String>;
  sex: () => Promise<String>;
  joinClubs: <T = FragmentableArray<Club>>(args?: {
    where?: ClubWhereInput;
    orderBy?: ClubOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  applications: <T = FragmentableArray<Application>>(args?: {
    where?: ApplicationWhereInput;
    orderBy?: ApplicationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rooms: <T = FragmentableArray<Room>>(args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  notifications: <T = FragmentableArray<Notification>>(args?: {
    where?: NotificationWhereInput;
    orderBy?: NotificationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  loginSecret: () => Promise<String>;
}

export interface Room {
  id: ID_Output;
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  participants: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  participants: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoomNullablePromise
  extends Promise<Room | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  participants: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Message {
  id: ID_Output;
  text: String;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  from: <T = UserPromise>() => T;
  to: <T = UserPromise>() => T;
  room: <T = RoomPromise>() => T;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  from: <T = UserSubscription>() => T;
  to: <T = UserSubscription>() => T;
  room: <T = RoomSubscription>() => T;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  from: <T = UserPromise>() => T;
  to: <T = UserPromise>() => T;
  room: <T = RoomPromise>() => T;
}

export interface Notification {
  id: ID_Output;
  userId: Int;
  content: String;
  checked: Boolean;
}

export interface NotificationPromise
  extends Promise<Notification>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<Int>;
  content: () => Promise<String>;
  checked: () => Promise<Boolean>;
}

export interface NotificationSubscription
  extends Promise<AsyncIterator<Notification>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  checked: () => Promise<AsyncIterator<Boolean>>;
}

export interface NotificationNullablePromise
  extends Promise<Notification | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<Int>;
  content: () => Promise<String>;
  checked: () => Promise<Boolean>;
}

export interface Question {
  id: ID_Output;
  subject?: String;
  type?: String;
  options: String[];
}

export interface QuestionPromise extends Promise<Question>, Fragmentable {
  id: () => Promise<ID_Output>;
  subject: () => Promise<String>;
  type: () => Promise<String>;
  options: () => Promise<String[]>;
}

export interface QuestionSubscription
  extends Promise<AsyncIterator<Question>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subject: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  options: () => Promise<AsyncIterator<String[]>>;
}

export interface QuestionNullablePromise
  extends Promise<Question | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subject: () => Promise<String>;
  type: () => Promise<String>;
  options: () => Promise<String[]>;
}

export interface ApplicationConnection {
  pageInfo: PageInfo;
  edges: ApplicationEdge[];
}

export interface ApplicationConnectionPromise
  extends Promise<ApplicationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ApplicationEdge>>() => T;
  aggregate: <T = AggregateApplicationPromise>() => T;
}

export interface ApplicationConnectionSubscription
  extends Promise<AsyncIterator<ApplicationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ApplicationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateApplicationSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ApplicationEdge {
  node: Application;
  cursor: String;
}

export interface ApplicationEdgePromise
  extends Promise<ApplicationEdge>,
    Fragmentable {
  node: <T = ApplicationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ApplicationEdgeSubscription
  extends Promise<AsyncIterator<ApplicationEdge>>,
    Fragmentable {
  node: <T = ApplicationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateApplication {
  count: Int;
}

export interface AggregateApplicationPromise
  extends Promise<AggregateApplication>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateApplicationSubscription
  extends Promise<AsyncIterator<AggregateApplication>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ClubConnection {
  pageInfo: PageInfo;
  edges: ClubEdge[];
}

export interface ClubConnectionPromise
  extends Promise<ClubConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClubEdge>>() => T;
  aggregate: <T = AggregateClubPromise>() => T;
}

export interface ClubConnectionSubscription
  extends Promise<AsyncIterator<ClubConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClubEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClubSubscription>() => T;
}

export interface ClubEdge {
  node: Club;
  cursor: String;
}

export interface ClubEdgePromise extends Promise<ClubEdge>, Fragmentable {
  node: <T = ClubPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClubEdgeSubscription
  extends Promise<AsyncIterator<ClubEdge>>,
    Fragmentable {
  node: <T = ClubSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClub {
  count: Int;
}

export interface AggregateClubPromise
  extends Promise<AggregateClub>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClubSubscription
  extends Promise<AsyncIterator<AggregateClub>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NotificationConnection {
  pageInfo: PageInfo;
  edges: NotificationEdge[];
}

export interface NotificationConnectionPromise
  extends Promise<NotificationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NotificationEdge>>() => T;
  aggregate: <T = AggregateNotificationPromise>() => T;
}

export interface NotificationConnectionSubscription
  extends Promise<AsyncIterator<NotificationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NotificationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNotificationSubscription>() => T;
}

export interface NotificationEdge {
  node: Notification;
  cursor: String;
}

export interface NotificationEdgePromise
  extends Promise<NotificationEdge>,
    Fragmentable {
  node: <T = NotificationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NotificationEdgeSubscription
  extends Promise<AsyncIterator<NotificationEdge>>,
    Fragmentable {
  node: <T = NotificationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNotification {
  count: Int;
}

export interface AggregateNotificationPromise
  extends Promise<AggregateNotification>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNotificationSubscription
  extends Promise<AsyncIterator<AggregateNotification>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionConnection {
  pageInfo: PageInfo;
  edges: QuestionEdge[];
}

export interface QuestionConnectionPromise
  extends Promise<QuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionEdge>>() => T;
  aggregate: <T = AggregateQuestionPromise>() => T;
}

export interface QuestionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionSubscription>() => T;
}

export interface QuestionEdge {
  node: Question;
  cursor: String;
}

export interface QuestionEdgePromise
  extends Promise<QuestionEdge>,
    Fragmentable {
  node: <T = QuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionEdgeSubscription
  extends Promise<AsyncIterator<QuestionEdge>>,
    Fragmentable {
  node: <T = QuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestion {
  count: Int;
}

export interface AggregateQuestionPromise
  extends Promise<AggregateQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionSubscription
  extends Promise<AsyncIterator<AggregateQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ApplicationSubscriptionPayload {
  mutation: MutationType;
  node: Application;
  updatedFields: String[];
  previousValues: ApplicationPreviousValues;
}

export interface ApplicationSubscriptionPayloadPromise
  extends Promise<ApplicationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ApplicationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ApplicationPreviousValuesPromise>() => T;
}

export interface ApplicationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ApplicationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ApplicationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ApplicationPreviousValuesSubscription>() => T;
}

export interface ApplicationPreviousValues {
  id: ID_Output;
  userId: Int;
  answer: String[];
  checked: Boolean;
  isPass?: Boolean;
}

export interface ApplicationPreviousValuesPromise
  extends Promise<ApplicationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<Int>;
  answer: () => Promise<String[]>;
  checked: () => Promise<Boolean>;
  isPass: () => Promise<Boolean>;
}

export interface ApplicationPreviousValuesSubscription
  extends Promise<AsyncIterator<ApplicationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<Int>>;
  answer: () => Promise<AsyncIterator<String[]>>;
  checked: () => Promise<AsyncIterator<Boolean>>;
  isPass: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClubSubscriptionPayload {
  mutation: MutationType;
  node: Club;
  updatedFields: String[];
  previousValues: ClubPreviousValues;
}

export interface ClubSubscriptionPayloadPromise
  extends Promise<ClubSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClubPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClubPreviousValuesPromise>() => T;
}

export interface ClubSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClubSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClubSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClubPreviousValuesSubscription>() => T;
}

export interface ClubPreviousValues {
  id: ID_Output;
  masterId: Int;
  name: String;
  bio: String;
  description: String;
  logo?: String;
  clubImage?: String;
  type: String;
  socialUrl: String;
  socialDisplay: Boolean;
}

export interface ClubPreviousValuesPromise
  extends Promise<ClubPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  masterId: () => Promise<Int>;
  name: () => Promise<String>;
  bio: () => Promise<String>;
  description: () => Promise<String>;
  logo: () => Promise<String>;
  clubImage: () => Promise<String>;
  type: () => Promise<String>;
  socialUrl: () => Promise<String>;
  socialDisplay: () => Promise<Boolean>;
}

export interface ClubPreviousValuesSubscription
  extends Promise<AsyncIterator<ClubPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  masterId: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  clubImage: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  socialUrl: () => Promise<AsyncIterator<String>>;
  socialDisplay: () => Promise<AsyncIterator<Boolean>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
  id: ID_Output;
  text: String;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
}

export interface NotificationSubscriptionPayload {
  mutation: MutationType;
  node: Notification;
  updatedFields: String[];
  previousValues: NotificationPreviousValues;
}

export interface NotificationSubscriptionPayloadPromise
  extends Promise<NotificationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotificationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotificationPreviousValuesPromise>() => T;
}

export interface NotificationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NotificationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NotificationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotificationPreviousValuesSubscription>() => T;
}

export interface NotificationPreviousValues {
  id: ID_Output;
  userId: Int;
  content: String;
  checked: Boolean;
}

export interface NotificationPreviousValuesPromise
  extends Promise<NotificationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  userId: () => Promise<Int>;
  content: () => Promise<String>;
  checked: () => Promise<Boolean>;
}

export interface NotificationPreviousValuesSubscription
  extends Promise<AsyncIterator<NotificationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  userId: () => Promise<AsyncIterator<Int>>;
  content: () => Promise<AsyncIterator<String>>;
  checked: () => Promise<AsyncIterator<Boolean>>;
}

export interface QuestionSubscriptionPayload {
  mutation: MutationType;
  node: Question;
  updatedFields: String[];
  previousValues: QuestionPreviousValues;
}

export interface QuestionSubscriptionPayloadPromise
  extends Promise<QuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionPreviousValuesPromise>() => T;
}

export interface QuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionPreviousValuesSubscription>() => T;
}

export interface QuestionPreviousValues {
  id: ID_Output;
  subject?: String;
  type?: String;
  options: String[];
}

export interface QuestionPreviousValuesPromise
  extends Promise<QuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  subject: () => Promise<String>;
  type: () => Promise<String>;
  options: () => Promise<String[]>;
}

export interface QuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  subject: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  options: () => Promise<AsyncIterator<String[]>>;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  encryptedPassword: String;
  phoneNumber?: String;
  studentNumber?: Int;
  Name?: String;
  isMaster?: String;
  sex?: String;
  loginSecret?: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  encryptedPassword: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  studentNumber: () => Promise<Int>;
  Name: () => Promise<String>;
  isMaster: () => Promise<String>;
  sex: () => Promise<String>;
  loginSecret: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  encryptedPassword: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  studentNumber: () => Promise<AsyncIterator<Int>>;
  Name: () => Promise<AsyncIterator<String>>;
  isMaster: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<String>>;
  loginSecret: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Notification",
    embedded: false
  },
  {
    name: "Application",
    embedded: false
  },
  {
    name: "Club",
    embedded: false
  },
  {
    name: "Question",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
